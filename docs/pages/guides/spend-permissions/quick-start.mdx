import { Callout } from "vocs/components";

# Getting Started with Spend Permissions

This guide will walk you through a simple example of building an app that leverages Spend Permissions, using [Viem](https://viem.sh/) and [Wagmi](https://wagmi.sh/).

TODO: directly post deployment addresses here w/ links to basescan?
For the contract deployment addresses see the contracts [README](https://github.com/coinbase/spend-permissions/blob/main/README.md).

<Callout type="info">
  **Tips**: If you need a template to start with, you can check out [Onchain App
  Template](https://github.com/coinbase/onchain-app-template/tree/main).
</Callout>

:::steps

### Create a spender client

This is an example of a spender that is a Coinbase Smart Wallet that is sponsored by a paymaster. 
EOAs or other smart contracts can also be spenders.

```ts [spender. ts]
import { createPublicClient, Hex, http } from "viem";
import { baseSepolia } from "viem/chains";
import { privateKeyToAccount } from "viem/accounts";
import {
  createBundlerClient,
  createPaymasterClient,
  toCoinbaseSmartAccount,
} from "viem/account-abstraction";

export async function getSpenderBundlerClient() {
  const client = createPublicClient({
    chain: baseSepolia,
    transport: http(),
  });

  const spenderAccountOwner = privateKeyToAccount(
    process.env.SUBSCRIPTION_PRIVATE_KEY! as Hex
  );

  const spenderAccount = await toCoinbaseSmartAccount({
    client,
    owners: [spenderAccountOwner],
  });

  const paymasterClient = createPaymasterClient({
    transport: http(process.env.BASE_SEPOLIA_PAYMASTER_URL),
  });

  const spenderBundlerClient = createBundlerClient({
    account: spenderAccount,
    client,
    paymaster: paymasterClient,
    transport: http(process.env.BASE_SEPOLIA_PAYMASTER_URL),
  });

  return spenderBundlerClient;
}
```

### Construct a `SpendPermission` object to obtain signed approval from the user

A `SpendPermission` is the struct that defines the parameters of the permission.
See the solidity struct [here](https://github.com/coinbase/spend-permissions/blob/07067168108b83d9662435b056a2a580c08be214/src/SpendPermissionManager.sol#L20).

```ts [Subscribe.tsx]

export default function Subscribe() {
...

  async function handleSubmit() {
    setIsDisabled(true);
    let accountAddress = account?.address;
    if (!accountAddress) {
      try {
        const requestAccounts = await connectAsync({
          connector: connectors[0],
        });
        accountAddress = requestAccounts.accounts[0];
      } catch {
        return;
      }
    }

    // Define a `SpendPermission` to request from the user    // [!code focus]
    const spendPermission = {  // [!code focus]
      account: accountAddress, // User wallet address // [!code focus]
      spender: process.env.NEXT_PUBLIC_SUBSCRIPTION_SPENDER! as Address, // Spender smart contract wallet address // [!code focus]
      token: "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE" as Address, // ETH (https://eips.ethereum.org/EIPS/eip-7528) // [!code focus]
      allowance: parseUnits("10", 18), // [!code focus]
      period: 86400, // seconds // [!code focus]
      start: 0, // unix time, seconds // [!code focus]
      end: 281474976710655, // max uint48 // [!code focus]
      salt: BigInt(0), // [!code focus]
      extraData: "0x" as Hex, // [!code focus]
    }; // [!code focus]

    ...

  return (
    <div>
      ...
    </div>
  );
}
```

### Obtain a signature over the spend permission from the user

The `SpendPermissionManager.sol` uses [ERC-712](https://eips.ethereum.org/EIPS/eip-712) signatures.
The following will prompt the user to sign this spend permission data with their smart wallet.

```ts [Subscribe.tsx]

export default function Subscribe() {
  ...

  async function handleSubmit() {
    ...

    // Obtain signature over `SpendPermission` from user  // [!code focus]
    try {
      const signature = await signTypedDataAsync({ // [!code focus]
        domain: { // [!code focus]
          name: "Spend Permission Manager", // [!code focus]
          version: "1", // [!code focus]
          chainId: chainId, // [!code focus]
          verifyingContract: spendPermissionManagerAddress, // [!code focus]
        }, // [!code focus]
        types: { // [!code focus]
          SpendPermission: [ // [!code focus]
            { name: "account", type: "address" }, // [!code focus]
            { name: "spender", type: "address" }, // [!code focus]
            { name: "token", type: "address" }, // [!code focus]
            { name: "allowance", type: "uint160" }, // [!code focus]
            { name: "period", type: "uint48" }, // [!code focus]
            { name: "start", type: "uint48" }, // [!code focus]
            { name: "end", type: "uint48" }, // [!code focus]
            { name: "salt", type: "uint256" }, // [!code focus]
            { name: "extraData", type: "bytes" }, // [!code focus]
          ], // [!code focus]
        }, // [!code focus]
        primaryType: "SpendPermission", // [!code focus]
        message: spendPermission, // [!code focus]
      }); // [!code focus]
      setSpendPermission(spendPermission); // [!code focus]
      setSignature(signature); // [!code focus]
    } catch (e) {
      // Handle error
    }
    setIsDisabled(false);
  }

    ...

  return (
    <div>
      ...
    </div>
  );
}
```

### Submit the signature to `SpendPermissionManager.approveWithSignature`

Spend permissions can be approved in two ways. The user can call `approve` directly with the details
of a spend permission to establish an approval for a spender. Alternatively, the user can sign the hash
of a spend permission and anyone can submit that signature and the details of the spend permission to
`approveWithSignature` (or `approveBatchWithSignature` in the case of a batch signature) to authorize
the approval. 

This example shows our spender app submitting the user's signature to approve the permission.

```ts [Subscribe.tsx]
// We send the permission details and the user signature to our 
// backend route
async function handleCollectSubscription() {
    setIsDisabled(true);
    let data;
    try {
      const replacer = (key: string, value: any) => {
        if (typeof value === "bigint") {
          return value.toString();
        }
        return value;
      };
      const response = await fetch("/collect", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(
          {
            spendPermission,
            signature,
            dummyData: Math.ceil(Math.random() * 100),
          },
          replacer
        ),
      });
      if (!response.ok) {
        throw new Error("Network response was not ok");
      }
      data = await response.json();
    } catch (e) {
      // Handle error
    }
    setIsDisabled(false);
    return data;
  }
```

We use our bundler client and the `SpendPermissionManager.sol` contract address and abi to call `approveWithSignature`
```ts [route.tsx]
import { NextRequest, NextResponse } from "next/server";
import { getSpenderBundlerClient } from "../../lib/spender";
import {
  spendPermissionManagerAbi,
  spendPermissionManagerAddress,
} from "../../lib/abi/SpendPermissionManager";

export async function POST(request: NextRequest) {
  const spenderBundlerClient = await getSpenderBundlerClient();
  try {
    const body = await request.json();
    const { spendPermission, signature } = body;

    const userOpHash = await spenderBundlerClient.sendUserOperation({
      calls: [ 
        { 
          abi: spendPermissionManagerAbi,
          functionName: "approveWithSignature",
          to: spendPermissionManagerAddress,
          args: [spendPermission, signature],
        },
      ],
    });

    const userOpReceipt =
      await spenderBundlerClient.waitForUserOperationReceipt({
        hash: userOpHash,
      });

    if (userOpReceipt.success) {
      console.log("Spend Permission approved");
    }

    ...
  }
  ...
}
```


### Spend user funds

If the permission was successfully approved, we're ready to spend.

```ts [route.tsx]
...

export async function POST(request: NextRequest) {
    ...

    const spendUserOpHash = await spenderBundlerClient.sendUserOperation({ // [!code focus]
      calls: [  // [!code focus]
        {         // [!code focus]
          abi: spendPermissionManagerAbi, // [!code focus]
          functionName: "spend", // [!code focus]
          to: spendPermissionManagerAddress, // [!code focus]
          args: [spendPermission, "1"], // spend 1 wei // [!code focus]
        }, // [!code focus]
      ], // [!code focus]
    }); // [!code focus]

    const spendUserOpReceipt =
      await spenderBundlerClient.waitForUserOperationReceipt({
        hash: spendUserOpHash,
      });

    return NextResponse.json({
      status: spendUserOpReceipt.success ? "success" : "failure",
      transactionHash: spendUserOpReceipt.receipt.transactionHash,
      transactionUrl: `https://sepolia.basescan.org/tx/${spendUserOpReceipt.receipt.transactionHash}`,
    });
  } catch (error) {
    // Handle error
  }
}

```
:::

That's it! We've successfully created and used permission to spend our user's funds.

TODO: link to more comprehensive documentation